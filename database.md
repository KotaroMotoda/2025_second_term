
# データベース第１０回

## 第１０章 質問処理の最適化

### 質問処理の流れ

質問として与えられるSQL文は，以下の4段階に分けて処理される

1. 質問を構文解析する
2. 最適化を行う
3. 内部スキーマレベルのオブジェクトコードを生成する
4. オブジェクトコードを実行し結果リレーションを得る

---

### 単純質問の処理コスト

**Q:**

```sql
SELECT ＊
FROM R
WHERE A=’a’
```

ただし，リレーションR(A,B)

- SQLの問いは非手続き的
- WHAT（何が欲しいのか）を表現
- HOW（所望のデータをどのような手続きで取ってくるか）は表現していない
- SQLの問いの処理の方法の工夫が重要

#### Qの処理

1. インデックスは定義されていない．従ってRへのアクセスはスキャン
2. インデックスが定義されている．
   - フィールドA上にインデックスXAがある
   - フィールドB上にインデックスXBがある
   - フィールドAとB上にそれぞれインデックスXAとXBがある

---

#### Qの処理詳細

1. インデックスは定義されていない．従ってRへのアクセスはスキャン
   - この処理コストは，
     - (Rのスキャン)+(A=’a’の計算)
2. インデックスが定義されている
   - a. フィールドA上にインデックスXAがある
     - この処理コストは，
       - (XAを使ってA=’a’のレコードの場所を探すコスト)
       - +(データをアクセスするコスト)
       - +(CPUコスト)
   - b. フィールドB上にインデックスXBがある
     - この処理コストは，
       - 1．と同じ
   - c. フィールドA,B上にそれぞれインデックスXA, XBがある
     - この処理コストは，
       - 今までの3種類の処理コストの一番少ない処理を選択できる

---

#### Qの処理まとめ

1. インデックスは定義されていない．従ってRへのアクセスはスキャン
2. インデックスが定義されている．
   - a. フィールドA上にインデックスXAがある
   - b. フィールドB上にインデックスXBがある
   - c. フィールドAとB上にそれぞれインデックスXAとXBがある

上記のそれぞれの場合のコストを見積もり，最適化を行う．その際，I/Oコストだけに注目し，CPU（計算）コストは無視することが多い．

---

### 結合質問の処理コスト

- 入れ子型ループ結合法
- ソートマージ結合法

#### 入れ子型ループ結合

- R(A,B)とS(B,C)の自然結合R＊Sを考える

```pseudo
for each tuple r in R do
    for each tuple s in S do
        if r[B]=s[B] then output r＊s
end
```

- RとSの順番に注意
- Sの結合属性上にインデックスが張られていると，処理効率は良くなる
- この場合のコストは
  - (Rをアクセスするコスト)
  - +N×(Sのインデックスを使ってアクセスするコスト)
  - +(計算するコスト)
  - ただし，NはRのタップルのうちSのタップルと結合可能なタップル数

#### ソートマージ結合法

- R(A,B)とS(B,C)のソートマージ結合
  - 結合属性BでR,Sをソートしておく
  - Rで一つ，Sで二つのポインタを使って結合処理
- コストは以下となる
  - (Rをソートするコスト)
  - +(Sをソートするコスト)
  - +(R,Sをマージするコスト)
  - +(計算するコスト)

---

### 質問処理コストの推定

- 質問処理の最適化には，処理コストの見積もり(推定)が必要
- 推定に使える統計値(メタデータ)などが保存されている
  - TCARD(R):Rの大きさ(データ保存のブロック数やページ数)
  - NINDEX(XA):インデックスXAの大きさ(ブロック数やページ数)
  - ICARD(XA):Rの中の属性Aの異なった値の数(DISTINCTな数)
  - インデックスXAの性質
    - クラスタードインデックス
    - ノンクラスタードインデックス

---

### クラスタードインデックス

```
10

7 15

5 7 9 10 12 15 13 18 20
```

**インデックスページ**

**データページ**

| 番号 | 名前   | 年齢   | 職業   |
|------|--------|--------|--------|
| 5    | 5名前  | 5年齢  | 5職業  |
| 7    | 7名前  | 7年齢  | 7職業  |
| 9    | 9名前  | 9年齢  | 9職業  |
| 10   | 10名前 | 10年齢 | 10職業 |
| 12   | 12名前 | 12年齢 | 12職業 |
| 13   | 13名前 | 13年齢 | 13職業 |
| 15   | 15名前 | 15年齢 | 15職業 |
| 18   | 18名前 | 18年齢 | 18職業 |
| 20   | 20名前 | 20年齢 | 20職業 |

---

### ノンクラスタードインデックス

```
10

7 15

5 7 9 10 12 15 13 18 20
```

**インデックスページ**

**データページ**

| 番号 | 名前   | 年齢   | 職業   |
|------|--------|--------|--------|
| 5    | 5名前  | 5年齢  | 5職業  |
| 7    | 7名前  | 7年齢  | 7職業  |
| 9    | 9名前  | 9年齢  | 9職業  |
| 10   | 10名前 | 10年齢 | 10職業 |
| 12   | 12名前 | 12年齢 | 12職業 |
| 13   | 13名前 | 13年齢 | 13職業 |
| 15   | 15名前 | 15年齢 | 15職業 |
| 18   | 18名前 | 18年齢 | 18職業 |
| 20   | 20名前 | 20年齢 | 20職業 |

---

### ヒューリスティックス

- R(A,B)とS(B,C)に関して

```sql
SELECT ＊
FROM R, S
WHERE R.B=S.B AND R.A=’a’
```
